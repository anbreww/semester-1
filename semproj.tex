%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                   Semester project 1	  	              %%
%%              Smart home energy monitoring   		      %%
%%                       Andrew Watson                        %%
%%                           MT-MA1                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{includes/preamble}
% duplicating graphicx here because of vim-latex autodetect
\newcommand{\thedate}{January 8, 2010}
\usepackage[pdftex]{graphicx} 
\usepackage{pdfpages}
\begin{document}
\begin{titlepage}
\nocite{*}      % to make sure bibliography appears in the correct order
  \begin{center}
     
     
    % Upper part of the page
    \includegraphics[width=4cm]{logo_epfl}\\[1.5cm]
     
    \textsc{\LARGE Microengineering }\\[1.0cm]

    \textsc{\Large ELab - Semester Project}\\[0.1cm]

    \vfill 
     
    % Title
    \HRule \\[0.7cm]
    { \huge \bfseries Smart home wireless sensing}\\[0.4cm]

    \includegraphics[width=0.6\textwidth]{sideview} 
     
    \HRule \\[2.0cm]
    
    %% Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        \emph{Author:} \\
        Andrew \textsc{Watson}\\[1.0cm]

        Microengineering\\
        Master - Semester 1\\[0.5cm]
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Supervisor:} \\
        Maher \textsc{Kayal}\\[0.5cm]

        \emph{Assistants:} \\
        Fabrizio \textsc{Lo Conte}\\
        Laurent \textsc{Fabre}\\[0.5cm]
      \end{flushright}
    \end{minipage} \\[2cm]
     
    \vfill
     
    % Bottom of the page
    {\large \thedate}
     
  \end{center}

\end{titlepage}
%\maketitle

\newpage{}

%\fancyhead{}
\fancyfoot{}
\lhead{}
\cfoot{\thepage}        % numéro de page..
\lfoot{Semester Project}
%\rfoot{\thedate}
\rfoot{\thedate} 

%\begin{abstract}
%\end{abstract}

\setcounter{secnumdepth}{5}

%\renewcommand\contentsname{Plan}  % Rename ``Table des Matières''
\tableofcontents{}

\newpage

%%%% BEGIN : LSTLISTINGS CONFIG %%%%%%
%%%% TODO : MOVE TO SEPARATE FILE ONCE FINISHED %%%%%
%% see http://www.jorgemarsal.com/blog/2009/06/08/source-code-snippets-in-latex/
\lstset{language=C}
%\definecolor{lightgrey}{RGB}{200,200,200}
\definecolor{grey97}{gray}{0.97}
\definecolor{grey92}{gray}{0.92}
\definecolor{grey75}{gray}{0.75}
\definecolor{grey45}{gray}{0.45}

\lstdefinestyle{console}
{
  numbers=none,
  %basicstyle=\bf\ttfamily,
  basicstyle=\ttfamily\footnotesize,
  backgroundcolor=\color{grey97},
  frame=lrtb,
  framerule=0.5pt,
  linewidth=\textwidth,
}
\lstdefinestyle{avr-c}
{
  style=console
}

\lstset{
  style=console
}

%%%%%%% END : LSTLISTINGS CONFIG %%%%%%%%


\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
\markboth{Introduction}{\MakeUppercase{Introduction}}
Smart energy management is one of the core applications of home automation. To
this end, many systems have been developed, but not many are in widespread use.
It is still an emerging business which can benefit from research, and is still
being very actively developed at the moment.

Here are some of the main features that a well integrated home automation system
could provide:
\begin{description}
  \item[Consumption] : indicate where energy is being consumed and by whom, as
    well as extract statistics, which can be linked to other factors, like for
    instance thermostat settings, outdoor temperature, activity in the
    home\ldots
  \item[React] to the environment : turn lights and other appliances on and off
    depending on activity and time of day. It would be interesting for example
    to turn off lights when no human presence is detected, to use power-hungry
    devices during the night to even out power usage, or to adjust the lighting
    to suit the amount of natural light coming in a room. 
\end{description}

The benefits of such a system are twofold : first, it has been
demonstrated\cite{darby2006} that simply providing people with data about their
energy consumption results in a substantial drop in power usage. It can also
help to make statistics and comparisons between devices and households.

Second, as described previously, it is possible to add a level of automation to
the system. Actions such as adjusting the lighting based on incoming sunlight or
the level of activity in a room for example are not common, but could lead to
energy savings. These are both fairly straightforward to implement and could
actually be implemented on the system developed in this semester project.

Another interesting application is remote control : rather than leave heating
and other things on all the time while away, it would be possible to turn them
off just after leaving the house, and turn them on a short time before arriving.
With most current-generation smartphones, it would even be possible to do all
this automatically, based on the user's position as determined by the phone's
internal GPS.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Context and previous work}

Several projects in the ELab have been focused around the idea of a Powerline
network : modules that plug into a regular household socket and transmit data
along the power lines. The first project by Thierry Barras\cite{barras2009}
involved the development of a set of modules that can communicate together on
the power network.

Later projects added a Wi-Fi interface\cite{sallin2010}, which allowed the nodes
to be controlled by any internet-capable device, a GSM module\cite{sallin2010},
which can accept commands by text messages, and a touch-screen interface.

These are some of the building blocks that could lead to a complete home
automation solution, allowing to control many aspects of day-to-day life
automatically, including electric blinds, appliances, security devices and home
entertainment.  One key area that is currently missing from these projects
though is the ability to interact with users and sensors in areas devoid of
mains electricity.

If a user wishes to add a light switch on a wall, measure the outdoor
temperature, or place motion detectors without pulling long and ugly extension
cords, that is not currently possible with the existing modules.

\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}
In view of the limitations exposed in the previous section, this semester
project aims to provide a base platform to extend the Powerline network with a
set of wireless nodes. These nodes should provide the ability to place motion
sensors, environmental sensors, and dimmer switches anywhere within a certain
distance of the powerline network. 

Some example applications would include placing a light switch on a desk, or
close to the remote control for a home entertainment system, to be able to dim
the lights without leaving one's chair. Humidity and temperature sensors could
be placed outside, or to monitor a wine cellar, without the need to install any
wiring.

The goal for this semester project is not necessarily to produce a final design
for a wireless sensor network, but rather to produce a working demonstration to
show how the technology could be used, as well as to explore some possibilities
in the reduction of power usage.  The wireless nodes that comprise the network
must operate on a small power source for as long a time as possible.

These were the main considerations when researching solutions for the various
functional blocks of the project. When possible, I favoured ease of use and
quick development over slight savings. Most of these could be made up for in a
later stage, if required.

At the end of this project, a small-scale implementation of the wireless sensor
network will be demonstrated. The layout and general operation of the
demonstration is described in \tref{sec:network-topology}. In its current state,
the wireless network can be extended easily by assembling and programming
additional wireless nodes, using the current hardware design.

At the time of writing, only two powerline modules were functional. At the
moment, each wireless node controls a specific powerline module (i.e. the module
with address \#2, the only one available at the time) If the powerline network is
to be extended in the future, it would be interesting to add functionality to
reconfigure the wireless nodes at runtime, to select different targets to
control.

\subsection{Power requirements}
Most of these modules will be running of their own limited power source. It is
thus essential that the power consumption be as low as possible. Low power usage
must be the main driving force behind all design decisions, so as to maximise
the autonomy of the wireless nodes. 

As a guideline, we would like the nodes to be able to run for several months
without needing to be recharged. In the event that the power runs out, it must
be easy to identify which nodes have run out of power, and they must be easy to
recharge. 

All these points have been accounted for in the hardware design, but most of
them have not yet been implemented in software. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solutions}
In light of these requirements, the first part of the project consisted of
reasearching solutions for the various building blocks. These were broken up
into three inter-dependent categories. 

I will first discuss which options were considered to supply power to the
modules, in \tref{sub:power-supply}. These are then compared with a list of
possible wireless transmission devices and protocols (\tref{sub:wireless}), which
will be managed by a microcontroller (\tref{sub:microcontroller}). All of these
have been chosen to operate in similar voltage ranges, while using as little
current as possible, in order to waste as little power as possible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Power supply}
\label{sub:power-supply}

From a brief overview of microcontrollers and wireless transmitters, it appears
that the most common solutions operate at voltages between \unit[2]{V} and
\unit[3.6]{V}. In addition, we expect our final system to use very little
average power (\unit[1-10]{$\mu$A}), composed of long periods at
\unit[1]{$\mu$A} or less, and small peaks at approximately \unit[50]{$\mu$A}. It
was also expected that some add-on boards may require a \unit[5]{V} power
source.

In addition, we would like our system to last over one month on a single charge, 
and for the design to be resonably straightforward, since development time is an
issue in the context of a semester project.

Lithium Polymer, Lithium ion and NiMH accumulators were both considered as
possible power source options. 

\begin{table}
  \centering
  \begin{tabular}{l|l|c}
    Solution	& Nominal Voltage	& Circuit Complexity \\
    \hline
    NiMH 	& \unit[0.7-1.4]{V}	& -	     \\
    NiMH x2 	& \unit[1.4-2.8]{V}	& -	     \\
    NiMH x3 	& \unit[2.1-4.5]{V}	& -	     \\
    LiPo 	& \unit[2.7-4.23]{V}	& ++	     \\
    Li-Ion 	& \unit[2.7-4.23]{V}	& ++	     \\
  \end{tabular}
  \caption{Comparative overview of power sources}
  \label{tab:battery-comparison}
\end{table}

As illustrated in \TAB{tab:battery-comparison}, the simplest and cheapest
implementation involves two NiMH batteries. With the requirements set
previously, this solution may not even require any voltage conversion, saving
one component which is most likely to dissipate power.

In a device with such low power consumption requirements, self-discharge becomes
an important feature to take into account, since the capacity lost through
self-discharging will be of the same order of magnitude as the power used by the
device itself.

All three solutions considered nowadays seem to offer very good self-discharge
rates, even in NiMH batteries, which used not to be the case. In recent years,
some commercial solutions have surfaced, offering batteries which offer
virtually no self-discharge past 70\% of their original
charge\cite{testingeneloop}. A fairly recent comparison of self-discharge rates
with these newer cells can be found at \cite{nimhvslipo}.

In light of these observations, it was decided that the modules would be powered
by two AA size NiMH rechargeable batteries. This offers the most flexibility for
the end user, as they are extremely easy to find, allows for quick and easy
testing using regular alkaline batteries, and does not require any specific
circuitry to manage over- and under-voltage protection. NiMH batteries can also
be trickle-charged at low currents without risking much damage, which may be a
useful feature in case the modules are to be retro-fitted with a solar charger
for instance.

More details about the actual implementation of the power supply are provided in
\tref{sub2:hardware-powersupply}.

\subsubsection{Use of a DC-DC converter}
After the choice was made to use NiMH batteries, a solution was evaluated to
provide constant power to the board. By using a DC-DC converter, it can
effectively be possible to squeeze a little more power out of the batteries, by
draining them lower than the operating voltage of our device, as well as
providing a more even supply voltage to our end circuit.

Considering the solutions described in the following sections, our device will
be capable of operating at voltages between \unit[2]{V} and \unit[3.6]{V}. The
preferred solution of two NiMH cells theoretically provides voltages between
\unit[1.4]{V} and \unit[2.8]{V}. Thus it seems interesting to extend the
operation of the circuit into the batterie's lower charge area. If the relation
between battery voltage and discharge were linear, this would provide us with a
substantial increase in operating time. However, as illustrated in
\FIG{fig:discharge-curve}, the discharge profile of NiMH batteries is very much
non-linear. Although the battery is considered ``dead'' around \unit[1.7]{V}, it
remains above \unit[2]{V} for over 90\% of its life.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.6\textwidth]{nimh-discharge-curve-commented}
  \end{center}
  \caption{Typical NiMH discharge curve}
  \label{fig:discharge-curve}
\end{figure}


To constrast with this, the best DC-DC converters I was able to find offer
efficiencies between 60-98\% (maximum efficiency is only achieved at a specific
load, and decreases if the target is drawing more or less current). The
buck/boost converters that were considered for this also demonstrate quiescent
currents of an order of magnitude comparable to the expected operating current
of the device, or higher. Based on these facts, this idea was dismissed for this
particular application, but it may be worth considering in a situation where the
current draw is higher and expected to be constant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wireless}
\label{sub:wireless}

Several wireless communication solutions were considered during the design
phase. We will begin with a brief overview of the solutions that were considered
for this application.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Microchip MRF24J40}

Microchip\furl{http://www.microchip.com} offer a series of integrated solutions
based on the 802.15.4\furl{http://en.wikipedia.org/wiki/IEEE_802.15.4-2006}
hardware standard. They are quite affordable (\$10 for the short range version),
but they require the installation of a wireless stack. The options provided by
Microchip are either \emph{MiWi}, which is a royalty-free, lightweight, and free
stack, or a full ZigBee stack.

Although the MiWi stack seems to fit our application quite well, the fact that
it is proprietary basically guarantees that we cannot ensure interoperability
with devices from other vendors, as well as forcing us to use Microchip's
platform for the foreseeable future. This is clearly not desirable as one of my
main objectives for this project was to ensure that it is scalable and can be
extended to other devices.

The ZigBee stack is an interesting alternative, as it is theoretically
compatible with any other ZigBee-certified device. It was discarded immediately
however as the base cost to install and use the framework is way outside the
scope of this project (over \$900 at the time of writing).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Nordic nRF24L01+}

The nRF24 series by Nordic Semiconductor\furl{http://www.nordicsemi.com/} is a
very interesting and cost-effective solution for small wireless networks. Their
chips are quite inexpensive (approx. \unit[7]{Chf}) and they provide a hardware
design which can be re-used with minimal work. Unfortunately, the system doesn't
appear to scale very well, as one chip can only communicate with six different
neighbours at a time. Beyond that, it requires some workarounds such as
frequency hopping, which may be interesting but would require too much work for
a project of this scope.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Other solutions}

A few other solutions were considered, such as the CC2520 family by Texas
Instruments\furl{http://ti.com}. This and many others were discarded because
they require an antenna to be designed into the PCB. These solutions would be
intresting from a cost perspective, as they are almost half as expensive as
other ready-made solutions, but having to design the RF circuitry would greatly
increase the potential for errors, and require too much design time. 

Finally, it was decided that the solution should be based on the IEEE 802.15.4
standard, provide easy interoperability between device and vendor types, and be
easy to implement, to avoid ``reinventing the wheel'' in terms of radio
transmissions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{ZigBee : defining reasons}
\label{sub:zigbee}

For most of the reasons mentioned above, the solution which was chosen for this
design were a set of XBee transmitters from Digi
International\furl{http://digi.com}. These modules are (in theory) very easy to
set up and get operational in a short time, and ensured that not too much time
would be wasted on the wireless transmission part of the project.

In addition, they are supposedly fully compliant with the
ZigBee\furl{http://zigbee.org} specification, which should allow the project to
be extended with devices from other vendors without having to replace the
existing hardware. The device footprint is easy to re-use in future projects
(simply place two \unit[2]{mm} headers with decoupling capacitors), without any
need for external antenna circuitry. It is also worth noting that these devices
can be reprogrammed and reconfigured wirelessly, from a program running on a PC.

Finally, I already had some personal experience with these devices, which would
give me a little head start in understanding how packets are assembled and
transmitted.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Afterthoughts}
%\label{sub2:afterthoughts}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Microcontroller}
\label{sub:microcontroller}
The microcontroller sits at the center of our design. It instructs the wireless
transmitter on when to wake up to begin transmitting, and takes care of sampling
the sensors at the right time and reacting to events using hardware
interruptions. Since it must be always on (or in sleep mode, with or without a
timer running), it is essential to choose a solution that uses very little
power.

After an overview of the solutions available to us, four were selected for a
closer comparison. \Tab{tab:microcontrollers} Summarizes the main power
consumption characteristics of these microcontrollers.

\begin{table}
  \centering
  \begin{tabular}{l|l|l|l|l}
    Microcontroller	& Sleep	& RTC Sleep & Normal & Min supply [V]	\\
    \hline
    ATXMEGAxxA4		& \unit[100]{nA} & \unit[600]{nA} &
    			$\unitfrac[300]{\mu{}A}{Mhz}$ & \unit[1.8]{V}	\\
    ATmegaxxxPA		& \unit[100]{nA} & \unit[650]{nA} &
    			$\unitfrac[400]{\mu{}A}{Mhz}$ & \unit[1.8]{V}	\\
    PIC24F16KA102	& \unit[20]{nA} & \unit[510]{nA} &
    			$\unitfrac[182]{\mu{}A}{Mhz}$ & \unit[1.8]{V}	\\
    MSP430F2001		& \unit[50]{nA} & \unit[600]{nA} &
    			$\unitfrac[170]{\mu{}A}{Mhz}$ & \unit[1.8]{V}	\\
  \end{tabular}
  \caption{Microcontroller comparison}
  \label{tab:microcontrollers}
\end{table}

Here are some orders of magnitude to keep in mind when evaluating the power
consumption of our microcontroller:
\begin{enumerate}
  \item A typical transmission will last less than \unit[20]{ms}. After
    experimenting, the longest time observed occured when the transmitter had to
    re-associate with the network after waking from sleep, resulted in a
    \unit[60]{ms} delay.
  \item In the case of sensors being sampled, the microcontroller will remain in
    sleep mode, and wake on intervals in the order of 30 seconds to several
    minutes. 
  \item In the case of a hardware button which is triggered by the user, the
    microcontroller can remain in deep sleep mode with all internal and external
    peripherals disabled, and wake only on external events. In this case, even
    if the button were to be activated fifty times per day, the device would
    only be waking on average once every half hour.
\end{enumerate}

For a rapid evaluation, let us estimate that our device will be active for
\unit[30]{ms} every \unit[30]{s}. This yields an active/sleep duty cycle of
$\unit[30]{ms}/\unit[30]{s}=10^{-3}=0.1\%$. Using the data from
\TAB{tab:microcontrollers}, and assuming a \unit[2]{Mhz} clock speed, we can see
that the average power consumed during normal operation, when averaged over a
complete period, is of the same order of magnitude as the current used in RTC
Sleep\footnote{RTC Sleep: all peripherals are disabled, except the Real Time
Clock counter, which wakes the microcontroller periodically} mode. We can thus
estimate the consumption of the microcontroller to approximately
\unit[1-10]{$\mu{}A$}.

The power source chosen was two rechargeable AA batteries. These typically
advertise approximately \unit[2000]{mAh} capacity. A quick calculation using the
previous estimations indicates that if the batteries were to power the
microcontroller alone, it would provide a life, if used correctly, of:

\begin{equation}
  \frac{\unit[2000]{mAh}}{\unit[10]{\mu{}A}} = 
  \frac{\unit[2]{Ah}}{\unit[10^{-5}]{A}} =
  \unit[200000]{h} = \unit[22]{years}
  \label{eq:battery-life}
\end{equation}

Which clearly shows that with the current generation of low-power
microcontrollers, this will be the last of our worries. Since the wireless
module advertises a standby (ready to receive) current in the order of
\unit[50]{mA}, it will be much more important to make sure that our wireless
transmitter remains asleep when we need it, rather than optimise the code in our
microcontroller to gain even a few milliseconds of execution time.

In light of all this, the preference went to Atmel's ATXMEGA solution, since it
seemed to provide the most flexibility and hardware features, while still
demonstrating power requirements very similar to the other (less feature-rich)
offerings.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Network topology}
\label{sec:network-topology}

Zigbee is designed to work well in a mesh configuration. However, this requires
some ``repeater'' nodes (routers) to be constantly on to relay transmissions
from the end nodes. Since the battery-powered devices cannot be expected to run
continuously, the network will function in a star topology.

In this configuration, the gateway device is powered from the grid, and the
wireless sensor nodes wake up at a given interval and transmit their data to the
gateway. The nodes do not require any incoming transmissions as they are
configured to transmit regularly. This is the most efficient way of saving
power, but it does limit functionality to a certain extent.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{flowcharts/topology-flows}
  \end{center}
  \caption{Topology chart illustrating information flows}
  \label{fig:topology-flows}
\end{figure}

If future applications require it though, it is possible to configure Zigbee end
nodes to wake up regularly and listen for incoming transmissions. If an end node
is asleep when a packet is sent to it, it will be buffered by the nearest router
or coordinator until the node wakes up. It is best to avoid this mode though,
since it reduces battery life, and causes an inherent delayed reaction time.

\Fig{fig:topology-flows} illustrates the topology chosen for the demonstration
which will be presented at the end of this project, and shows which way
information flows. 


This scenario demonstrates a simple network of four nodes. At the center of it,
the Gateway acts as a coordinator, and can receive transmissions from any other
node. Any node which wishes to join the network must connect to the coordinator
and is attributed a 16-bit local address. The network uses a local identifier to
regroup all the nodes, which is referred to as a PAN ID. The coordinator is
configured to use PAN ID \bash{0x1984}.

Two nodes react to user interaction, and send commands either to dim a lamp or
to turn it on when it detects movement. These commands are sent to the gateway
and forwarded to the powerline network.

A third node takes periodic measurements of its sensor values, but rather than
sending them through the powerline network, they are sent directly to a receiver
connected to a computer by USB. From there, the data can be logged and graphed
from a MATLAB or Python script on the host computer. Additionally, it would be
possible to act on the data and send commands to the powerline network from the
computer, wirelessly. This however is not implemented in the current demo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For reference, the addresses of the five modules used in this project are listed
in \TAB{tab:addresses}. These addresses may be used to communicate to a specific
device if the short (16-bit) local address is not known. The addresses for known
modules are already contained in the source code for quick re-use.

\begin{table}[h]
  \centering
  \begin{tabular}{l|l|l}
    Address & Node ID & Type \\
    \hline
    0x13A2004064EFC2 & NODE0 & Coordinator \\
    0x13A2004064EFCC & NODE1 & End device \\
    0x13A2004064EFEB & NODE2 & End device \\
    0x13A2004064EFC1 & NODE3 & End device \\
    0x13A2004064EFF1 & NODE4 & Router \\
    %\hline
  \end{tabular}
  \caption{Zigbee device address list}
  \label{tab:addresses}
\end{table}

We can see here that nodes 1 to 3 were configured as end devices. This means
that their sole purpose is to initiate communications, or receive them as they
wake periodically from sleep. They will not assist the network by forwarding
messages. If nodes are to be placed further from the gateway than the range of
the transmitters allow, it would be advised to add a powered device, configured
as a router, somewhere in between the remote device and the gateway, to extend
the range of the network. It must be noted that only \emph{one} ZigBee device
can act as a coordinator. 

\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hardware design}

This section will detail the different hardware parts that make up this project. 
It will begin with the base platform which is common to all devices, and will be
followed by a presentation of each of the add-on modules that were developed for
evaluating the platform.

Some mistakes were noticed only after fabrication, and some corrections have
been made. Since they are not relevant to the understanding of the project, they
have been placed in the appendix. However, it is highly recommended to read
through this errata before starting to use the wireless modules, and especially
if the design files are to be used again or modified. The list can be found in
Section \tref{sec:design-changes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Base board}

Each sensor node consists of a basic board and a sensor add-on. The basic board
provides standard features common to all the nodes, such as network
connectivity, power management, and processing.

\Fig{fig:base-topview} shows the basic hardware, with the wireless transmitter
in the center, just above the expansion port. On the left are the UART interface
to the powerline modules (bottom), the JST connector for an external charger
(middle), and a power switch (not present). LEDs above the XBee module indicate
its current status. These must not be placed on the battery-powered nodes, as
they will increase the power usage. Six extra I/O pins are available on the
right-hand side, mainly intended for debug purposes.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{top-view}
  \end{center}
  \caption{Top view of the wireless node base hardware}
  \label{fig:base-topview}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Overview}

The main board is made up of several elements. At its core is an ATXMEGA. This
microcontroller was chosen mainly for its scalability and low power
requirements. The microcontroller communicates through a serial link with the
XBee, its radio transmitter.

The sensor nodes have a few on-board sensors which are available on all versions
of the board. These include an ambient light sensor, which is pointed towards
the front of the board, some measurements of supply voltages, as well as
temperature of the microcontroller. As the power usage is meant to be very low,
it was assumed that the temperature readings would not suffer very much from
the activity of the chip itself.

Power is supplied mainly by batteries which are placed directly on the board,
and can be recharged from an external interface. A power switch can be toggled
by the user to turn the node on and off.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Microcontroller}

Although the project was originally supposed to use an ATXMEGA32A4, no suppliers
had the part ready to order when the design started. Luckily, code written for
one device of the XMEGA family is completely portable to any other, excluding
the ports and peripherals that do not exist in one or the other. Therefore,
rather than use the intended 44-pin microcontroller, we used a version with more
I/O pins, namely the ATXMEGA64A4. To ensure that the code and design would be
easily back-portable to the smaller microcontroller (to save on hardware costs),
the extra pins were either unused, or used as debug pins. Six pins of port F
were thus dedicated to the purpose of debugging. 

The connections between the microcontroller and other peripherals in the board
can be found in section \tref{sub:sch-wirelessmodule} of the appendix.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Power supply}
\label{sub2:hardware-powersupply}

The nodes can have various power sources. They were designed to function on two
AA batteries, which provide voltages between 2 and \unit[3.2]{V}. All components
on the board were chosen to operate in this voltage range.

To reduce the size requirements, the batteries are placed directly on the board,
on either side of the the radio transmitter. 

On the left side of the board, a 4-pin JST header provides a connection to an
external charger (or solar power module). The power lines can be disconnected by
the main controller, and two communication lines are available for information
exchange between the sensor node and its power source. These lines are connected
to the ATXMEGA's USART lines in case serial communication is desired.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{blocks/wm_solar_charging}
  \end{center}
  \caption{External charger connection}
  \label{fig:solar-charger}
\end{figure}

As illustrated in \FIG{fig:solar-charger}, a resistor divider placed before the
switch allow the host microcontroller to measure the external voltage, without
having to connect it. The output of the block outlined in
\FIG{fig:solar-charger} is connected directly to the batteries. The external
source is expected to manage the charging current.

In addition to this, the input voltage can be measured with a voltage divider,
and disconnected if it is not needed. The ATXMEGA has a built-in module for
measuring its own supply voltage, using a 10x voltage divider with a \unit[1]{V}
reference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Gateway device}

Each network is normally comprised of one gateway device. This device uses the
same basic hardware as the sensor node, although it requires less components.

Its sole purpose is to forward incoming wireless transmissions onto the
Powerline network to control the Powerline devices. In its current
implementation, it simply parses the ZigBee packets, strips them of all the
additional information (headers, checksums, addressing etc.) and then forwards
the data onto the Powerline nodes.

On one hand, this means that the nodes are free to send any data they wish,
since it does not have to be interpreted by the gateway, but at the same time,
the commands for the powerline network must be embedded into the end nodes. The
main advantage of this situation is that if some functionality is added to a
powerline module, and a wireless node is added to complement it, there is no
need to reprogram the gateway to take these new features into account.

Since the gateway device is destined to be plugged in to a wall socket, it will
always be active and listening for transmissions. It functions as the network
coordinator. Therefore, any packets which must be transmitted to the Powerline
network are to be addressed to the ZigBee coordinator, whose 64-bit address is :
\bash{00:00:00:00:00:00:00:00}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sensor boards}

The main feature of the base board is its ``expansion port''. In order for the
nodes to share as much hardware as possible, they were all designed with the
same basic peripherals. All the additional sensors and interfaces specific to
different types of nodes were to be added on an expansion board which could be
exchanged between devices. As such, it is possible to change the structure of a
network simply by replacing a very small part of the hardware. As the plug-in
boards are very small, they are also very cheap and easily replaceable.

Although none of the current sensor boards uses all the features of the
expansion port, is was designed to provide any functionality that one may
require. The expansion port uses a two-way, 20-pin connector with a \unit[2]{mm}
pitch.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.7\textwidth]{blocks/wm_sensor_io}
  \end{center}
  \caption{Sensor expansion port}
  \label{fig:sensor-io}
\end{figure}

As can be seen on the schematic, the expansion port provides the following
connectivity:
\begin{description}
  \item [Switchable power supply] The port provides two supply voltages, one of
    which can be turned on and off from the microcontroller
  \item[ADC] Several pins are connected to the analog to digital converter.
  \item[DAC] Both digital to analog pins are available.
  \item[AC] Two pins can be routed to the analog comparator module.
  \item[USART] The USART module provides serial communication.
  \item[\IIC{}] An \IIC{} bus is available to communicate with sensors.
  \item[SPI] data lines for master or slave functionality.
\end{description}

Due to the layout of the board, the sensor add-ons have to be very small. In
order to reduce the vertical space needed by the sensors nodes, the batteries
and radio transmitters were placed on the same face of the board as the add-on
connector. Therefore, the space left is only approximately \unit[22x20]{mm$^2$}.
This is sufficient however for most basic applications. If more space is needed,
it is assumed that the designer will route the necessary connections on the
add-on board, then connect any other sensors off-board using connector cables.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Motion sensor}

As its name indicates, the purpose of this board is to detect movement. This
task is achieved by some commercially available PIR sensors. These are cheap and
easy to use, but the downside is that they require a \unit[5]{V} supply voltage
to function. To test these functions, a mini PIR module was acquired from Seeed
Studio\furl{http://www.seeedstudio.com/depot/tiny-pir-motion-sensor-module-p-277.html}.

The specifications on this device are very terse, but it is claimed to use a
constant \unit[50]{$\mu$A} current.

The hardware design of this board is straightforward : a charge pump converter
provides the supply voltage to the sensor(s), whose inputs are connected to two
microcontroller input pins, where they can trigger interrupts. One sensor board
is equipped with two connectors, to potentially drive two seperate PIR modules
from one wireless node. Schematics for the motion sensor add-on board can be
found in section \tref{sub:sch-motionboard} of the appendix.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.6\textwidth]{flowcharts/motion-flowchart-colour}
  \end{center}
  \caption{Motion sensor node operation}
  \label{fig:motion-flowchart}
\end{figure}

Although they require very little power to function, the PIR modules need a
permanent supply voltage in order to function. Therefore, the power supply must
be constantly enabled. Fortunately, since these modules produce a logical
output, the radio and microcontroller can remain in deep sleep mode until the
interrupt is triggered. For optimal performance though, it would be best to use
a sensor which can operate at the same voltages as the base module, therefore
improving the overall efficiency by removing the charge pump regulator.

A few measurement were made of the motion board add-on. Regardless of supply
voltage (which was tested from \unit[2]{V} to \unit[3.2]{V}, the current
consumption of the motion sensor with its DC-DC converter came in at
$\unit[250]{\mu{}A}$ in ``standby'' mode, and went up to
$\unit[300]{\mu{}A}$ when movement was detected. This corresponds to a power
usage of $\unit[500]{\mu{}W}$ to $\unit[1]{mW}$.

In the current demonstration, the motion sensor node is configured to turn on a
lamp when motion is detected. If no movement is detected for a period of 30
seconds, the light is turned off again. \Fig{fig:motion-flowchart} shows the
basic functionality of the motion sensor module.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Environmental sensors}

The environment sensing board is comprised of three sensors:

\begin{itemize}
  \item Barometer
  \item Temperature sensor
  \item Capacitive humidity sensor
\end{itemize}


The barometer and temperature were both chosen for their low consumption and
easy communication (both use the I$^{2}$C bus on the expansion port).

The capacitive humidity sensor was chosen for its price, but as a consequence,
it is very inaccurate and requires calibration.

The program for reading the sensors is very basic: the microcontroller turns off
all communication interfaces on the sensors and goes to sleep, leaving the RTC
clock running. It then wakes up at regular intervals, queries the sensors for
new information, sends it to the USB module, and goes back to sleep.
Unfortunately, the sensors are not 100\% functional in the demonstration.
Details can be found in section \tref{sub:problems-sensors} in the appendix.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Light controller}

The final module is intended to control lights. It provides connections for two
momentary switches, as well as two potentiometers which can be turned on and
off. With this module, the microcontroller can be configured to remain in deep
sleep and only wake up on a hardware interruption generated by the switches, or
to wake up periodically to sample the potentiometer.

The board itself includes footprints for SMD switches, for testing purposes, but
since the nodes are eventually meant to reside in cases, the buttons and
potentiometers are to be fixed to the enclosure and connected to the add-on
board using cables. This allows a little flexibility in the physical design of
the nodes.

Since a potentiometer dissipates power when it is connected, it has been placed
on a microcontroller pin. It is only enabled just before making a reading, and
then disconnected. It is advisable to wait a short while after enabling the
potentiometer, to charge the ADC input capacitor before initiating a conversion.
Details of the add-on board can be found in section \tref{sub:sch-dimmerboard} of
the appendix.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.95\textwidth]{flowcharts/dimmer-flowchart-colour}
  \end{center}
  \caption{Dimmer node operation}
  \label{fig:dimmer-flowchart}
\end{figure}

\Fig{fig:dimmer-flowchart} shows how the dimmer node is expected to work. In
this example, one button is used to toggle the light on and off, and the second
button activates dimmer mode. 

If the light is off, and either button is pressed, the light will turn on. If
the on/off button is pressed, it will turn on to 100\%. If the dimmer button is
pressed, it will continuously take the value read from the potentiometer, until
it is turned off.

In order to provide a pleasant experience, the delay between readings of the
potentiometer should be fairly short. Since we also wish to save power where
possible, the delay between readings can be increased after a period of
inactivity.

Pressing the on/off button at any time when the light is turned on (even dimly),
will turn the light off.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{USB Adapter}
\label{sub2:xbee-usb}

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{3d-xbeeusb}
  \end{center}
  \caption{XBee USB Adapter}
  \label{fig:xbeeusb}
\end{figure}

In order to facilitate development and testing, a small board was made,
based on some existing projects\footnote{Mainly Sparkfun's USB XBee Explorer :
\url{http://www.sparkfun.com/products/8687}}, which provides a USB-Serial
interface to an XBee module. Using this device, it is possible to quickly
assemble packets to test communication between modules, as well as receive
communications from the modules. In the demonstration, this is used to receive
temperature and ambient light data from the sensor node, which can then be
logged on the computer and displayed on screen.

\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Software considerations}

As all the nodes (gateway and end devices) share the same hardware platform, it
makes sense to share as much as possible of the code base between devices.

The original idea had been to write the same code for all the devices, who could
then automatically detect which role they were to play in the network, and
configure themselves at runtime to fulfil the necessary function. This approach,
though probably feasible in terms of code size, would have required too much
work early on in the hardware design, as well as more code than could probably
be expected for a semester project. It would in my mind be more interesting to
have a very modular system than to hard-code the functionality of various
modules, and have several code bases for different nodes.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.95\textwidth]{flowcharts/code-hierarchy}
  \end{center}
  \caption{Example code hierarchy (not all files are listed)}
  \label{fig:code-hierarchy}
\end{figure}

With this in mind, the code is organised as in \FIG{fig:code-hierarchy}.
All code shares a common root. The folder \bash{xmega\_libs} contain libraries
that are specific to the XMEGA microcontroller, mostly provided by Atmel.
Although many hardware-level functions and registers were used in the main
program, mainly for lack of time, the main objective would be to abstract all
the hardware-level functionality to these libraries, to ease portability to
another microcontroller platform.

Next we have \bash{project\_libs}, which contains all shared code relevant to
this semester project. In here, we have libraries for communicating with the
XBee radios, sending commands to the Powerline modules, as well as collecting
information from all types of sensor modules.

Finally, in the \bash{project\_libs} folder, the \bash{hardware.h} file contains
all the pin definitions relevant to the layout of the board. All functions
should use the definitions provided in this file rather than hard-code port
names. This way, existing code can be made to work on a different hardware
design simply by replacing the \bash{hardware.h} file.

Lastly, since each type of node behaves differently, it has its own set of
files. The \bash{motion\_sensor} folder contains the behaviour for a motion
sensing node, \bash{dimmer\_board} contains the code for a dimmer node, and so
on. Usually, the \bash{main.c} file is the only file that differs between the
various nodes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cost considerations}

For the sake of ease of development, some sacrifices were made in the area of
cost. For starters, the ATXMEGA is not very well suited to extremely low-cost
designs, as it is slightly more expensive than some competing solutions,
especially the PIC24F series and Cortex M3. On the other hand, it offers a very
modern architecture with many features to experiment with, which allows a lot of
freedom for development and experimenting.


The main area were cost was overlooked at the benefit of development time
is the wireless interface. Indeed, the average cost of an XBee module is
approximately \$22, whereas it is possible to source modules from Microchip for
instance that cost less than half as much. However, these require a one-time
purchase of an expensive software stack (which is not included), as well as a
more complex development. Therefore, the XBee modules were chosen, for their
seemingly ``plug-and-play'' functionality. If more time could be spend on the
development, it would be reasonable to expect to spend up to three times less on
the radio transmitter modules, while keeping the same functionality and
compatibility with the existing modules.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Test results}

Once the network was up and running, and each node's functionality had been
verified, some tests were performed to verify whether our power consumption
objectives could be met.

In order to verify this, the environmental sensor node was connected to a power
source, and configured for a typical application. In this test, the node was set
to sleep for a short period, wake up the radio transmitter, sample the sensors
while the radio is waking up, transmit the data, then re-enter sleep mode and
repeat. The ZigBee radio was set to Power Mode ``High'', and Boost Mode was
disabled.

In this situation, the maximum current draw (at \unit[3.2]{V}), was of
\unit[20]{mA} during a transmission. The average power draw in sleep mode was
measured at $\unit[800]{\mu{}A}$. Since the time awake is so much shorter than
the time spent sleeping, the overall average consumption of the module is below
\unit[0.9]{mA}. The expected lifetime of the module with the current
configuration is therefore : 

\begin{equation}
  \frac{\unit[2000]{mAh}}{\unit[0.9]{mA}} = \unit[2222]{hours} = \unit[93]{days}
  \label{eq:env-sensors-consumption}
\end{equation}

Which clearly fits the requirements for several months of battery usage.
Furthermore, it is worth noting that there are many software improvements that
can still be made to improve power consumption. Some of them are listed
hereafter for
future reference. Most of these recommendations, and other details, can be found
in Application Note AVR1010\cite{avr1010}.

\begin{itemize}
  \item Turn off hardware modules when they are not used. Most unused
    peripherals are deactivated in the program's initialization routine.
    However, to be more power-efficient, each module should only be turned on
    when it is needed, and immediately deactivated thereafter.
  \item Set all unused pins to either pull-up or pull-down, and deactivate the
    digital buffer on pins connected to analog sources.
  \item Experiment with clock speeds and sources to find the most efficient
    combination. Since a lot of time is spent waiting for sensor readings, and
    for the radio to wake up, it may be worth decreasing the processor speed to
    consume less power. Alternatively, it could be configured to sleep during
    these periods.
  \item Disable the JTAG interface.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

Overall, the proposal outlined at the beginning of this project has been
sucessfully implemented. Using the modules developed during this semester
project, it is now possible for several wireless devices to interact with the
existing powerline network, and remotely control appliances.

The hardware design is functional, and can be demonstrated as requested.
However, not everything is fully functional, and many areas could be improved.
Some of these, mostly the hardware changes, are described in section
\tref{sec:design-changes} of the appendix. During the first phase of the
project, a lot of time was spent researching solutions. In addition to this, the
hardware design required more time than expected.

Because of this, too little time was left to develop the software part of the
project, and run in-depth tests for power consumption. This is quite
unfortunate, as it was destined to be one of the central points of the design.

Nevertheless, the time spent on the hardware seems to have yielded a fairly
decent platform with which to experiment in the future, and I am quite confident
that by spending some time with the software, it will be possible to achieve
some interesting results. The tests performed with the current prototypes
indicate that with very little optimization, it should be possible to run a
device for several months on one pair of batteries, which was one of our
objectives for this project.

There are lots of options open for developing the software, of which I would
like to mention two possible options.

First, the current implementation only uses one gateway between the wired and
wireless network, which stands as a single point of failure : if the gateway
goes offline for some reason, the whole wireless network will fail. It might be
interesting to add the possiblity to have several gateways for one network,
which would serve both to improve the reliability of the network, as well as
increase its range.

The second point is that the current network is very ``dumb''. The destination
node is hard-coded into each device's configuration. To be able to serve any
practical purpose, a network such as this one should offer some form of
auto-configuration and node discovery. Devices should advertise their presence
upon joining a network, and it should be possible at any time to build a network
map. The nodes should probably also implement some form of beacon mode, where
they report their status periodically to the coordinator, so that the user may
be notified if some nodes go missing, or are about to run out of power.

All these, I believe, could be worth exploring in the future, and I hope that
this platform may serve a purpose beyond the scope of this semester project.

\vspace{3cm}
Ecublens, Saturday January 8th,

\vspace{2cm}
Andrew Watson



\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{ieeetr}
\bibliography{biblio-semproj}

\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design changes}
\label{sec:design-changes}

As is often the case with a first prototype, some mistakes were made in the
design of the first batch of PCBs. I will not list every single modification
that has been made since the first version, but some of these bear mentioning,
in case the files or PCBs are to be re-used in a future design.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{UART Interface}
On the current fabricated version of the modules, the RX and TX pins were
inverted in the schematic. Obviously, the RX pin of the gateway should go to the
TX pin of the powerline module and vice versa. On the current gateway, this has
been corrected by cutting traces on the PCB. It has \emph{not} been done on the
other modules. Please ensure that you cross those two traces if you wish to use
any of the other modules to connect to a powerline module!

In addition to this, the connector footprint is upside down. Since it is a
side-facing connector, it is not possible to reverse it. Therefore, \emph{the
cable used to connect the gateway to the powerline modules must be reversed}.
This error has \emph{not been corrected} in the PCB files. This probably
deserves to be fixed in the next version, to avoid confusion with connecting
cables.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ambient light sensor}
The phototransistor used was chosen for its low current. However, it does not
have a very wide dynamic range. The inline resistor may need to be changed to
get better results, depending if the target application is to measure sunlight
or ambient light in a room.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sensor I/O}
The sensor expansion port was originally designed as on the schematic drawing,
to be reversible without causing any damage by shorting power pins to ground.
Due to an unfortunate difference in numbering between the schematic and the PCB
footprint, the pins do not appear to be in the same order as on the schematic.
Therefore please refer to the PCB drawing for correct pin names and numbers, and
take care when connecting an extension board not to reverse it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{JTAG connector}
In order to save precious space on the circuit board, the original programming
headers were replaced with a \unit[1.27]{mm} 2-row connector for JTAG debugging
and programming. It is possible to connect any AVR compatible programmer using
either the standard \unit[2.54]{mm} JTAG or PDI connectors, using the included
adapters.

After testing, it does appear that \unit[1.27]{mm} seem a lot less robust and
less pleasant to use than the larger version. If space permits, I would
recommend using a larger connecter on a possible future revision of the board.

In addition to this, the connector is currently placed slightly too close to the
wireless transmitter. It is therefore necessary to remove the transmitter to be
able to connect or disconnect the JTAG adapter, which is obviously not very
desirable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{JST Connector}
The JST connector included on the board was not intended to be used in the scope
of this project, and the interface has thus not been tested. On the current
version, the holes in the PCB are slightly too small. The connector pins must
therefore be filed off (with a Dremel tool for instance) before they will fit in
the footprint. This error has been corrected in the latest version of the Altium
files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Add-on boards}
\label{sub:problems-sensors}
Most features of the add-on boards have been tested and are functional, however
a few issues remain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Humidity Sensor}
\label{sub2:humidity}
As the design of the sensor boards occured fairly late in the project timeline,
some features were not extensively tested due to lack of time. Specifically, the
humidity sensor was not given much attention. The sensor was chosen for its very
low price, but the downside of this is that it requires proper calibration, as
the absolute humidity rating can vary by over \unit[40\%]{RH} (on a scale of
zero to \unit[100\%]{RH}, obviously). The sensor is rather useless without a
proper calibration process, which requires either an environment with controlled
humidity, or a well-calibrated reference sensor. At the time of writing, it has
not yet been tested, and therefore the charging resistor may need to be
recalculated and modified.

% Barometer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Barometer}
\label{sub2:barometer}
The barometer chip on the environmental sensor board has been implemented and
successfully tested. Raw ADC readings for pressure and temperature can be made,
as well as loading of the calibration coefficients. An attempt was made
at porting the example code from the Freescale application
note\cite{freescale3785}

It seems however that the results are not quite accurate. It was deemed
therefore that the time needed to debug this would be better spent elsewhere, as
some other areas are in need of more attention.

\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Schematics}
\subsection{Wireless base module}
\label{sub:sch-wirelessmodule}
\includepdf[landscape=true, pages={1,2,3}]{pdfs/WirelessModule_Schematics.PDF}

\subsection{Motion sensor add-on}
\label{sub:sch-motionboard}
\includepdf[landscape=true, pages={1,2}]{pdfs/motionboard}

\subsection{Dimmer add-on}
\label{sub:sch-dimmerboard}
\includepdf[landscape=true, pages={1,2}]{pdfs/dimmerboard}

\subsection{Environmental sensor add-on}
\label{sub:sch-sensorsboard}
\includepdf[landscape=true, pages={1,2}]{pdfs/sensorsboard}

\subsection{XBee USB Adapter}
\label{sub:sch-usbboard}
\includepdf[landscape=true, pages={3,1}]{pdfs/xbee-adapter}

\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Microcontroller software}

In order to save paper, the source code for the devices will not be reproduced
in the paper version of this report. All source code, both for the
microcontrollers and for this report are versioned using git and are hosted on 
Github\furl{http://github.com}. For the foreseeable future, the code will live
at the following address : \url{http://github.com/tunebird/semester-1-code}.

The \LaTeX{} source for this report can be found at the following address :
\url{http://github.com/tunebird/semester-1}.

 XMEGA-specific libraries were provided with Atmel application notes, and can be
 found as part of the XMEGA software
 framework\furl{http://asf.atmel.no/xmega/readme.html}. The files used in this
 project are included in the online repository for this semester project.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Project Libraries}
%\label{an:project-libs}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{XBee code}
%\bash{xbee.h}
%\lstinputlisting[language=C]{../code/project_libs/xbee.h}
%\bash{xbee.c}
%\lstinputlisting[language=C]{../code/project_libs/xbee.c}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Hardware definitions}
%\bash{hardware.h}
%\lstinputlisting[language=C]{../code/project_libs/hardware.h}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Debug functions}
%\bash{debug.h}
%\lstinputlisting[language=C]{../code/project_libs/debug.h}
%\bash{debug.c}
%\lstinputlisting[language=C]{../code/project_libs/debug.c}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Powerline interface}
%\bash{powerline.h}
%\lstinputlisting[language=C]{../code/project_libs/powerline.h}
%\bash{powerline.c}
%\lstinputlisting[language=C]{../code/project_libs/powerline.c}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Built-in sensors}
%\bash{builtin\_sensors.h}
%\lstinputlisting[language=C]{../code/project_libs/builtin_sensors.h}
%\bash{builtin\_sensors.c}
%\lstinputlisting[language=C]{../code/project_libs/builtin_sensors.c}
%
%%%%%%%%%%%
%\pagebreak
%%%%%%%%%%%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Motion Sensor Node}
%\label{an:motion-code}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Motion sense library}
%\bash{board\_motion.h}
%\lstinputlisting[language=C]{../code/project_libs/board_motion.h}
%\bash{board\_motion.c}
%\lstinputlisting[language=C]{../code/project_libs/board_motion.c}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Motion sense main file}
%\bash{main.c}
%\lstinputlisting[language=C]{../code/node-motion/main.c}
%
%%%%%%%%%%%
%\pagebreak
%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Dimmer Node}
%\label{an:dimmer-code}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Dimmer library}
%\bash{board\_dimmer.h}
%\lstinputlisting[language=C]{../code/project_libs/board_dimmer.h}
%\bash{board\_dimmer.c}
%\lstinputlisting[language=C]{../code/project_libs/board_dimmer.c}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Dimmer main file}
%\bash{main.c}
%\lstinputlisting[language=C]{../code/node-dimmer/main.c}
%
%%%%%%%%%%%
%\pagebreak
%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Environment Sensing Node}
%\label{an:environment-code}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Environment sense library}
%\bash{board\_sensors.h}
%\lstinputlisting[language=C]{../code/project_libs/board_sensors.h}
%\bash{board\_sensors.c}
%\lstinputlisting[language=C]{../code/project_libs/board_sensors.c}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Environment sense main file}
%\bash{main.c}
%\lstinputlisting[language=C]{../code/node-sensors/main.c}
%
%%%%%%%%%%%
%\pagebreak
%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{ZigBee to Powerline Gateway}
%\label{an:gateway-code}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Environment sense main file}
%\bash{gateway.c}
%\lstinputlisting[language=C]{../code/gateway/gateway.c}
%
%%%%%%%%%%%
%\pagebreak
%%%%%%%%%%%


\end{document}

